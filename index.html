<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TT Space Rocks</title>
  <style>
    * {
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
    body {
      width: 100%;
      height: 100vh;
      overflow: hidden;
      background: black;
    }
    #pontuacao {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      font-family: Arial, sans-serif;
      display: none;
    }
    #tela-inicial, #tela-game-over {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.9);
    }
    #tela-game-over {
      display: none;
    }
    canvas {
      display: none;
    }
    .btn {
      width: 200px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .btn:hover {
      transform: scale(1.1);
    }
    #instrucoes {
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 20px;
    }
    #instrucoes p {
      margin: 8px 0;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="pontuacao">Pontos: 0</div>

  <div id="tela-inicial">
    <img src="imagens/titulo.png" alt="Título do jogo"/>
    <img id="start-btn" class="btn" src="imagens/botao.png" alt="Botão Iniciar"/>
    
    <div id="instrucoes">
      <p>Use as setas ⬅ ➡ para mover a nave.</p>
      <p>Pressione <strong>Espaço</strong> para atirar.</p>
      <p>Desvie das rochas e destrua o máximo que puder!</p>
    </div>
  </div>

  <div id="tela-game-over">
    <img src="imagens/gameover.png" alt="Game Over"/>
    <img id="restart-btn" class="btn" src="imagens/botao.png" alt="Botão Reiniciar"/>
  </div>

  <canvas></canvas>

  <script>
    const width = window.innerWidth;
    const height = window.innerHeight;
    const canvas = document.querySelector('canvas');
    canvas.width = width;
    canvas.height = height;
    const c = canvas.getContext('2d'); //Utiliza o canvas no contexto 2d para desenhar a nave, rochas e etc.

    const naveImg = new Image();
    naveImg.src = 'imagens/Spaceship-PNG-File.png';
    const rochaImg = new Image();
    rochaImg.src = 'imagens/stone_PNG13556.png';

    const atualizarPontuacao = (pontos) => //Exibe a pontuação na tela.
      document.getElementById("pontuacao").innerText = Pontos = ${pontos}; 
    
    const iniciarJogo = () => {
      document.getElementById("tela-inicial").style.display = "none";
      document.getElementById("tela-game-over").style.display = "none";
      canvas.style.display = "block"; // Esconde os outros elementos e mostra o canvas
      document.getElementById("pontuacao").style.display = "block"; // Mostra a pontuação

      estadoGlobal.valor = {
        nave: { x: width / 2 - 50, y: height - 100 }, // Exibe a nave na parte baixa da tela
        rochas: criarRochas(), // Chama a função criarRochas pra exibir as rochas
        tiros: [], // Armazena os tiros em uma lista
        pontos: 0, // Começa com a pontuação zerada
        ativo: true // Starda o jogo
      };

      atualizarPontuacao(0);
      animate(); // Chama a função animate para iniciar o jogo de fato
    };
    
    const mostrarGameOver = () => {
      document.getElementById("tela-game-over").style.display = "flex";
      canvas.style.display = "none"; // Esconde o canvas e mostra a tela de game over, quando um é exibido, o outro aparece.
      document.getElementById("pontuacao").style.display = "none"; // Esconde a pontução, mesma lógica da ocultação do canvas
    };
    
    const atirar = (estado) => {
      estadoGlobal.valor = {
        ...estado, // Copia tudo do estado (naves, rochas, tiros...) usando o conceito de imutabilidade
        tiros: [
          ...estado.tiros, // Sobrescreve tiros com o novo tiro (também usando imutabilidade)
          {
            x: estado.nave.x + 45,
            y: estado.nave.y - 20,
            width: 10,
            height: 20,
            speed: 5
          }
        ]
      };
    };

    const animate = () => {
      const estado = estadoGlobal.valor; //armazena os dados do jogo
      if (!estado.ativo) return; //para a função se o usuário perdeu

      requestAnimationFrame(animate); //se chama recursivamente
      c.fillStyle = "black";
      c.fillRect(0, 0, width, height);

      c.drawImage(naveImg, estado.nave.x, estado.nave.y, 100, 100); //desenha a nave

      const novasRochas = estado.rochas.map((rocha) => { //usa o conceito de map para aplicar as funções abaixo
        const novaY = rocha.y + 2; //Faz as rochas descerem 2 pixels a cada atualização do canvas
        return novaY > height
          ? { x: Math.random() * (width - 50), y: 0 }
          : { ...rocha, y: novaY }; //Se a rocha chegar no fim da tela, randomiza o x dela e a leva ao topo da tela novamente
      });

      const novosTiros = estado.tiros
        .map((tiro) => ({ ...tiro, y: tiro.y - tiro.speed })) // Usa map para "subir" todos os tiros no momento em que são gerados
        .filter((tiro) => tiro.y > 0); // Usa o filter para exibir apenas os tiros com y maior que 0, ou seja, que ainda estão na tela

      const { tirosAtualizados, rochasAtualizadas, pontosGanho } = verificarColisoes(novosTiros, novasRochas); //Armazena os dados retornado pela função de verificarColisoes em um objeto

      const naveColidiu = rochasAtualizadas.some((rocha) =>
        checkCollision(estado.nave, rocha) // retorna true ou false se alguma rocha colidiu ou não com a nave
      );

      if (naveColidiu) {
        mostrarGameOver(); // Se colidiu, chama a função mostrarGameOver
        estadoGlobal.valor = { ...estado, ativo: false }; // Congela o jogo
        return;
      }

      const novoPontoTotal = estado.pontos + pontosGanho;
      atualizarPontuacao(novoPontoTotal); // Script que atualiza a pontuação somando os atuais com os ganhos

      estadoGlobal.valor = {
        ...estado,
        rochas: rochasAtualizadas,
        tiros: tirosAtualizados,
        pontos: novoPontoTotal
      }; // Atualiza o estadoGlobal

      rochasAtualizadas.forEach((rocha) =>
        c.drawImage(rochaImg, rocha.x, rocha.y, 50, 50)
      ); // Exibe cada rocha na posição atualizada

      c.fillStyle = 'red'; // Pinta os tiros de vermelho para que eles apareçam na tela
      tirosAtualizados.forEach((tiro) =>
        c.fillRect(tiro.x, tiro.y, tiro.width, tiro.height) // Faz os tiros terem o formato de retângulos
      );
    };
    
    const checkCollision = (rect1, rect2) =>
      rect1.x < rect2.x + 50 &&
      rect1.x + 100 > rect2.x &&
      rect1.y < rect2.y + 50 &&
      rect1.y + 100 > rect2.y; //Checa a colisão utilizando retângulos, caso se sobrepuserem, é porque colidiram.

    const criarRochas = () =>
      Array.from({ length: 5 }, () => ({
        x: Math.random() * (width - 50),
        y: 0 //Cria um array com 5 objetos(rochas) com x aleatorio e y = 0
      }));

    const estadoGlobal = { valor: null }; // Cria o espaço para guardar as informações

    const verificarColisoes = (tiros, rochas) =>
      tiros.reduce( // Usa o reduce para armazenar os tiros, rochas e pontos ganhos
        ({ tirosAtualizados, rochasAtualizadas, pontosGanho }, tiro) => {
          const colisaoIndex = rochasAtualizadas.findIndex((rocha) =>
            checkCollision(tiro, rocha) // verifica se o tiro colidiu com a rocha
          );
          if (colisaoIndex !== -1) { // Colidiu?
            const novaRocha = {
              x: Math.random() * (width - 50), 
              y: 0 // Gera a rocha com x aleatório e y = 0
            };
            return {
              tirosAtualizados,
              rochasAtualizadas: rochasAtualizadas.map((r, i) => // aplica um map nas rochas
                i === colisaoIndex ? novaRocha : r
              ), //substitui apenas a atingida
              pontosGanho: pontosGanho + 10 // adiciona a pontuação
            };
          }
          return {
            tirosAtualizados: [...tirosAtualizados, tiro],
            rochasAtualizadas,
            pontosGanho
          };
        },
        { tirosAtualizados: [], rochasAtualizadas: rochas, pontosGanho: 0 }
      );// Retorna todos os elementos atualizados

    const moverNave = (estado, direcao) => {
      const novoX =
        direcao === "direita"
          ? Math.min(estado.nave.x + 40, width - 100) // se for para a direita, aumenta 40 ao x
          : Math.max(estado.nave.x - 40, 0); // se for para esquerda, diminui 40 ao x
      estadoGlobal.valor = { ...estado, nave: { ...estado.nave, x: novoX } }; // Retorna os novos objetos atualizados
    };

    window.addEventListener("keydown", function (e) { // Executa sempre que uma tecla é pressionada
      const estado = estadoGlobal.valor; // Pega o estado global atual
      if (!estado || !estado.ativo) return; // Vê se o jogo começou

      if (e.key === "ArrowRight") moverNave(estado, "direita"); //move para a direita se a seta direita for pressionada
      if (e.key === "ArrowLeft") moverNave(estado, "esquerda"); //move para a esquerda se a seta esquerda for pressionada
      if (e.key === " " || e.key === "Spacebar") atirar(estado); // Chama a função atirar se a barra de espaço for acionada
    });

    document.getElementById("start-btn").addEventListener("click", iniciarJogo); //atribui a função de iniciar jogo quando o botão de "play" é clicado
    document.getElementById("restart-btn").addEventListener("click", iniciarJogo); //atribui a função de iniciar jogo quando o botão de "play", exibido quando o jogador perde, é clicado
  </script>
</body>
</html>